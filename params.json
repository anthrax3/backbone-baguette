{"name":"Backbone-baguette","tagline":"Freshly toasted backbone library. Provides tools and helpers for a super quick backbone development in smalls to mediums applications.","google":"","body":"# Backbone Baguette\r\n\r\nNothing better than concrete examples to understand how you can baguettize your Backbone development.\r\n\r\n###### Examples data\r\n\r\nAll the following examples will use the following models and collection : \r\n\r\n```javascript\r\n\r\n// Basic models and collection\r\nvar Car = Backbone.Model.extend({});\r\nvar toyota = new Car({brand:\"Toyota\",name:\"Yaris\"});\r\nvar bmw = new Car({brand:\"BMW\",name:\"M3\"});\r\n\r\nvar Garage = Backbone.Collection.extend({});\r\nvar myGarage = new Garage([toyota,bmw]);\r\n```\r\n###### Render a Model View\r\n\r\nWhen we're writing in Backbone, we quickly notice that we're writing a lot of similar views which are actually just using a template engine (such as Mustache or Handlebars) to render a JSON converted model. Instead of re-writing all the time the *template(this.model.toJSON())..* code you can baguettize it to achieve this.\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.CompositeView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\",\r\n  tagName:\"div\"\r\n});\r\n\r\nvar myView = new ModelView({model:toyota});\r\n\r\nmyView.render().$el.appendTo('body'); // Appends to the body \"My car is a Toyota Yaris\"\r\n```\r\nHere we are using a \"classic\" Mustache-style template; but the default template engine used in Baguette is Handlebars. \r\n\r\nIf you wish to change this, you have to edit the global configuration of Baguette and change the templating function, which takes a string template and a JSON object and return the templated string. \r\n\r\n```javascript\r\nvar TemplatingFunction = function(tpl,data) {\r\n        return Handlebars.compile(tpl)(data);\r\n};\r\nBackbone.Baguette.templating = TemplatingFunction;\r\n```\r\n\r\nYou can also specify individually the templating property on each CompositeView, if you want to only edit some views and not the global Baguette templating function.\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.CompositeView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\",\r\n  templating:function(tpl,data) {\r\n     return MyCustomTemplateEngine(tpl).CustomRenderMethod(data);\r\n  }\r\n  tagName:\"div\"\r\n});\r\n```\r\n\r\n*As I am a fanatic of RequireJS, **tpl** attribute is now **only supporting** a raw string because I'm using the awesome text plugin to load asynchronosouly my .tpl files. Support for a jQuery selector to fetch a <script> text/template will be added*\r\n\r\n\r\n###### Rendering a collection\r\n\r\nYou can use a Composite View to **render a collection** and avoid to write the redundant *this.collection.each(....)* code.\r\n\r\nTo achieve this you can define the **modelView** parameter which is either a Backbone.View (or a Baguette CompositeView obviously) definition (not an instance!) or either a parameter object which can contain the traditional Backbone Views parameters to create an el, such as **tagName**, **className**, etc...\r\n\r\n*If you use the second option, Baguette will create \"anonymous\" views inside the render function for you. Therefore you won't be able to define custom attributes on theses views, are they will be originals Baguette CompositeView objects.*\r\n\r\n**Creating a Collection View using a parameter object**\r\n\r\n```javascript\r\nvar GarageView = Backbone.Baguette.CompositeView.extend({\r\n  tagName:\"ul\",\r\n  tpl:\"I have a {{brand}} {{name}} in my garage\",\r\n\r\n  modelView:{\r\n   tagName:\"li\"\r\n  }  \r\n\r\n});\r\n\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render();\r\n```\r\n\r\n**Creating a Collection View using a View definition**\r\n\r\nThis will achieve the same thing as above, but I can create a custom view to define events and so. This is the recommended approach when Views are more complex. If your views are only used to \"display\" data, the above option may be preffered.\r\n\r\n```javascript\r\nvar CarView = Backbone.Baguette.CompositeView.extend({\r\n   tpl:\"I have a {{brand}} {{name}} in my garage\",\r\n   events:{\r\n     \"click\":\"onClick\"\r\n   },\r\n   onClick:function() {\r\n    console.log(this.model.toJSON());\r\n   }\r\n});\r\n\r\nvar GarageView = Backbone.Baguette.CompositeView.extend({\r\n  tagName:\"ul\",\r\n  tpl:\"I have a {{brand}} {{name}} in my garage\",\r\n  modelView:CarView\r\n\r\n});\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render();\r\n```\r\n\r\n*Your model views are passed all the options you gave to your GarageView instance; except the options related to the DOM such as tagName, etc...*\r\n\r\nThe baguette's components are availables under the **Backbone.Baguette** namespace;\r\n\r\n# CompositeView\r\n\r\nA CompositeView is a view that is a kind of hybrid view able to render a collection or a model following a **template** with a very few number of arguments. It avoids the redundant templating and collection looping code and allows us to write less code.\r\n\r\nJust like Backbone Views, you can (and you must!) inherit from a CompositeView to be able to use all its power.\r\n\r\n```javascript\r\nvar MyViewClass = Backbone.Baguette.CompositeView.extend({\r\n   // properties goes here\r\n});\r\n\r\n// Classic instantiation of the view\r\nvar myView = new MyViewClass();\r\n\r\n```\r\n\r\n# Global Configuration","note":"Don't delete this file! It's used internally to help with page regeneration."}