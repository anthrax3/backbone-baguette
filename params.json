{"body":"# Backbone Baguette\r\n\r\nNothing better than concrete examples to understand how you can baguettize your Backbone development.\r\n\r\n###### Examples data\r\n\r\nAll the following examples will use the following models and collection : \r\n\r\n```javascript\r\n\r\n// Basic models and collection\r\nvar Car = Backbone.Model.extend({});\r\nvar toyota = new Car({brand:\"Toyota\",name:\"Yaris\"});\r\nvar bmw = new Car({brand:\"BMW\",name:\"M3\"});\r\n\r\nvar Garage = Backbone.Collection.extend({});\r\nvar myGarage = new Garage([toyota,bmw]);\r\n\r\n// And a more complex Model\r\nvar garageLocation = new Backbone.Model({city:\"Paris\",gps:\"0.55 0.12\"});\r\nvar garageModel = new Backbone.Model({name:\"Peugeot\",location:garageLocation,cars:myGarage});\r\n\r\n```\r\n###### Render a Model View\r\n\r\nWhen we're writing in Backbone, we quickly notice that we're writing a lot of similar views which are actually just using a template engine (such as Mustache or Handlebars) to render a JSON converted model. Instead of re-writing all the time the *template(this.model.toJSON())..* code you can baguettize it to achieve this, by using the **Backbone.Baguette.ModelView** component.\r\n\r\n**With Backbone Baguette**\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.ModelView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\"\r\n});\r\n\r\nvar myView = new ModelView({model:toyota});\r\n\r\nmyView.render().$el.appendTo('body'); // Appends to the body \"My car is a Toyota Yaris\"\r\n```\r\n\r\nHere we are using a \"classic\" Mustache-style template; but the default template engine used in Baguette is Handlebars. \r\n\r\nIf you wish to change this, you have to edit the global configuration of Baguette and change the templating function, which takes a string template and a JSON object and return the templated string. \r\n\r\n```javascript\r\nvar TemplatingFunction = function(tpl,data) {\r\n        return Handlebars.compile(tpl)(data);\r\n};\r\nBackbone.Baguette.templating = TemplatingFunction;\r\n```\r\n\r\nYou can also specify individually the templating property on each CompositeView, if you want to only edit some views and not the global Baguette templating function.\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.ModelView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\",\r\n  templating:function(tpl,data) {\r\n     return MyCustomTemplateEngine(tpl).CustomRenderMethod(data);\r\n  }\r\n});\r\n```\r\n\r\nSince I am a fanatic of [RequireJS](http://requirejs.org/), tpl attribute is for now only supporting a raw string because I'm using the awesome [text plugin](https://github.com/requirejs/text) to load asynchronosouly my .tpl files. Support for a jQuery selector to fetch a script text/template will be added soon!\r\n\r\n**Without Backbone Baguette**\r\n\r\nBasically we are rewriting all the time the good old render method which pretty much looks always the same...\r\n\r\n```javascript\r\nvar ModelView = Backbone.View.extend({\r\n\r\n    render:function() {\r\n      var templated = Handlebars.compile(tpl)(this.model.toJSON());\r\n      this.$el.html(templated);\r\n      return this;         \r\n    }  \r\n});\r\n```\r\n\r\n###### Rendering a collection\r\n\r\nYou can use the **Backbone.Baguette.CollectionView** to avoid writing the redundant *this.collection.each(....)* code.\r\n\r\nTo achieve this you can define the **modelView** parameter which is either a Backbone.View (or a Baguette CompositeView obviously) definition (not an instance!) or either a parameter object which can contain the traditional Backbone Views parameters to create an el, such as **tagName**, **className**, etc...\r\n\r\n**Creating a Collection View using a View definition**\r\n\r\n```javascript\r\nvar CarView = Backbone.Baguette.ModelView.extend({\r\n   tpl:\"I have a {{brand}} {{name}} in my garage\", \r\n   tagName:\"li\",\r\n   events:{\r\n     \"click\":\"onClick\"\r\n   },\r\n   onClick:function() {\r\n    console.log(this.model.toJSON());\r\n   }\r\n});\r\n\r\nvar GarageView = Backbone.Baguette.CollectionView.extend({\r\n  tagName:\"ul\",\r\n  modelView:CarView\r\n});\r\n\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render();\r\n```\r\n\r\n*Your CarViews are passed all the options you gave to your GarageView instance; except obviously the options related to the DOM such as tagName, className, etc...*\r\n\r\n**Creating a Collection View using a parameter object**\r\n\r\n```javascript\r\nvar GarageView = Backbone.Baguette.CollectionView.extend({\r\n  tagName:\"ul\",\r\n  modelView:{\r\n   tagName:\"li\",\r\n   tpl:\"I have a {{brand}} {{name}} in my garage\"\r\n  }  \r\n});\r\n\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render().$el.appendTo('body'); // Our list is appended to the DOM\r\n```\r\n*If you use a parameter object, Baguette will create \"anonymous\" views inside the render function for you. Therefore you won't be able to define custom attributes -like events or so- on these views, are they will be originals Baguette ModelView objects.*\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\nvar GarageView = Backbone.View.extend({\r\n\r\n    render:function() {\r\n      var that = this;\r\n      this.$el.empty();\r\n      this.collection.each(function(model) {\r\n         var newView = new CarView({model:model});\r\n         that.$el.append(newView.render().$el);\r\n      })\r\n      return this;\r\n    }\r\n\r\n})\r\n```\r\n###### Auto bind your view\r\n\r\nBaguette automatically binds your View to the given model (or the given collection). That is, you don't need to rewrite the this.model.on(...) redundant code. We will here reuse the previous CarView.\r\n\r\n**With Backbone Baguette**\r\n\r\n```javascript\r\n\r\nvar myView = new CarView({model:toyota});\r\nmyView.render().$el.appendTo('body'); // <div>My car is a Toyota Yaris</div>\r\n\r\ntoyota.set({name:\"Yaris 2012\"});\r\n// View is automatically refreshed and is set to <div>My car is a Toyota Yaris 2012</div>\r\n```\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\nvar CarView = Backbone.View.extend({\r\n\r\n   initialize:function() {\r\n    this.model.on('change',this.render,this);\r\n   },\r\n   render:function() {\r\n    var templated = Handlebars.compile(tpl)(this.model.toJSON());\r\n    this.$el.html(templated);\r\n    return this;\r\n   }\r\n\r\n});\r\n```\r\n\r\nCollections are also auto binded on the add, reset & remove events, and are calling the render method to repaint the collection view when these events occur.\r\n\r\n```javascript\r\nvar myGarageView = new GarageView({collection:myGarage});\r\nmyGarageView.render().$el.appendTo('body');\r\n\r\nmyGarage.fetch(); // Will auto-render the view if new models are fetched\r\nmyGarage.add({brand:\"Peugeot\",name:\"306\"}); // View is refreshed with new model\r\nmyGarage.remove(toyota); // View is refreshed without the toyota model\r\n```\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\n\r\nvar GarageView = Backbone.View.extend({\r\n\r\n    initialize:function() {\r\n      this.collection.on('add reset remove',this.render,this);\r\n    },\r\n\r\n    render:function() {\r\n      var that = this;\r\n      this.$el.empty();\r\n      this.collection.each(function(model) {\r\n         var newView = new CarView({model:model});\r\n         that.$el.append(newView.render().$el);\r\n      })\r\n      return this;\r\n    }\r\n\r\n})\r\n```\r\n\r\n**I don't want my Composite Views to auto-bind themselves!**\r\n\r\nWell then you can right now exit this page. But seriously, you can just add the **noBind** attribute to a ModelView and a CollectionView and set it to **true**; either by defining it in your Class definition, either by passing it as an option when you instantiate your CompositeView.\r\n\r\n```javascript\r\nvar NoBindView = Backbone.Baguette.ModelView.extend({\r\n   noBind:true\r\n});\r\n\r\n// Or you can just do\r\nnew Backbone.Baguette.CollectionView({noBind:true})\r\n```\r\n\r\n###### Create generic loaders for all your models/collections\r\n\r\nThis is not really a Baguette component, but actually Baguette in its source code is patching the **Backbone.sync** method to add a custom \"syncing\" event when an AJAX call is made. So, for instance, each time you want to fetch a model or a collection, the concerned object will emit the \"syncing\" event that you will be able to observe, just like the sync/change/reset events. You can then make a generic loader that will work everywhere on any model in your application :\r\n\r\n```javascript\r\nvar Loader = Backbone.View.extend({\r\n  tagName:'img',\r\n  className:'hidden',\r\n  attributes:{\r\n   'src':'loader.gif'\r\n  },\r\n  initialize:function() {\r\n   this.model.on('syncing',this.$el.show,this.$el);\r\n   this.model.on('change',this.$el.hide,this.$el);\r\n  }\r\n});\r\n\r\nvar customLoader = new Loader({model:toyota});\r\ncustomLoader.render().$el.appendTo('body');\r\ntoyota.fetch(); // Loader is displayed, and will hide when call is over.\r\n```\r\n\r\nIf you are **already overriding** Backbone.sync you can style call the custom Baguette implementation by using the Backbone.Baguette.sync reference\r\n\r\n```javascript\r\nBackbone.sync = function(method,model,options) {\r\n\r\n  // Doing my custom stuff here \r\n   \r\n  Backbone.Baguette.sync(method,model,options);\r\n}\r\n```\r\n\r\n###### Avoid memory leaks and ghosts views\r\n\r\n[Courtesy of Addy Osmani](http://addyosmani.github.com/backbone-fundamentals/#whats-the-best-way-to-combine-or-append-views-to-each-other)\r\n\r\nBasically, when you remove a view from the DOM (using the .remove() native Backbone method), the jQuery events are removed by jQuery itself. But, if you binded your views to a model or a collection, these bindings still exist, and thus, the View cannot be garbage collected as it still have \"connection\" with other objects.\r\n\r\nTo avoid this, all the Baguette components are extending from a base component : **Backbone.Baguette.BaseView**\r\n\r\nBaseView provides the **bindTo** and **destroy** methods which are used to cache our bindings (to remove them later) and properly destroy the view. So if you don't want to use some \"high-level\" baguette components such as CollectionView or so, you can extend from BaseView instead of extending from Backbone.View. The only thing is that you have to remember is **to use this.bindTo instead of this.model.on(..)**\r\n\r\n```javascript\r\n\r\nvar BasicView = Backbone.Baguette.BaseView.extend({\r\n\r\n   initialize:function() {\r\n      this.bindTo(this.model,\"event_name\",this.callback,this);\r\n      // Edited addy's function to add context\r\n   }\r\n\r\n});\r\nvar basicView = new BasicView({model:toyota})\r\nbasicView.destroy(); // All the assigned events are properly cleaned + view is removed from the DOM\r\n\r\n```\r\n\r\nPlease note that the **CollectionView** and the **CompositeModelView** are automatically calling **destroy** on their child views, to guarantee that every inner views is properly cleaned.\r\n\r\n###### Rendering Nested Views\r\n\r\nBaguette offers you the ability to manage your nested views in an elegant and simple way. We often need to embed views in a view in order to separate tasks, or for other many reasons. Let's say we want to build a view for a Car and insert to this view a Button that will react to a click. We don't want to bind the click event on the Car view since we can imagine the button View can be reused elsewhre on the application. \r\n\r\nYou can Baguettize it this way :\r\n\r\n```javascript\r\n\r\nvar SelectButton = Backbone.Baguette.BaseView.extend({\r\n\r\n  tpl:'Info',\r\n  className:'btn btn-primary', // twitter bootstrap styling\r\n  events:{\r\n    'click':'onClick'\r\n  },\r\n  onClick:function() {\r\n    console.log(this.model.toJSON());\r\n    // Print informations or do stuff on Click.\r\n  } \r\n\r\n});\r\n\r\nvar CarView = Backbone.Baguette.CompositeModelView.extend({\r\n   \r\n  tpl:'<p>{{brand}} - {{name}}</p><button class=\"info\"></button>',\r\n  nestedViews:{\r\n    \".info\":SelectButton\r\n  }\r\n\r\n});\r\n\r\nvar myCarView = new CarView({model:toyota});\r\nmyCarView.render().$el.appendTo('body');\r\n// The inner button is rendered and ready to handle the click!\r\n// Our Car View is also filled with the good *brand* and *name* values\r\n\r\n```\r\nIn the above example, our SelectButton class is instantiated within the CarView render method. Note that *all the options -except DOM options-* we passed to the CarView when we instantiated it (so here it is {model:toyota}) are given to the nested views.\r\n\r\nBy default Baguette is using the selector as the **el** for our nested View. But you can also still auto-create the **el** for your nestedView, and add several others options by passing a parameter object which follows this syntax :\r\n\r\n```javascript\r\nvar CarView = Backbone.Baguette.CompositeModelView.extend({\r\n   \r\n  tpl:'<p>{{brand}} - {{name}}</p><button class=\"info\"></button>',\r\n  nestedViews:{\r\n    \".info\":{\r\n        class:SelectButton,\r\n        setElement:false // Will append the View INSIDE the selector instead of \"replacing\" it\r\n     }\r\n  }\r\n\r\n});\r\n\r\nvar myCarView = new CarView({model:toyota});\r\nmyCarView.render().$el.appendTo('body');\r\n// Now we have the following DOM elements on our body :\r\n// <div><p>Toyota - Yaris</p><button class=\"info\"><div>Info</div></button></div>\r\n// As we set setElement to false our NestedView is auto-creating its $el which is appended\r\n// to our .info container. (tagName is \"div\" by default in backbone)\r\n\r\n```\r\n\r\n###### Deeper dive in Nested Views : mixing it up\r\n\r\nWe saw how to use CompositeModelView to manage our nested views. It happens that sometimes, our models are a little bit more complex than plain raw JSON object (like our **garageModel** we defined in the examples). Well, CompositeModelView can handle that pretty well as you can see :\r\n\r\n```javascript\r\n    // locationView which will be nested. Simple model view\r\n    var locationView = Backbone.Baguette.ModelView.extend({\r\n        tpl:\"In {{city}} at gps coord {{gps}}\"\r\n    })\r\n    // Our more complex layout for a garage complex object\r\n    var compositeView = Backbone.Baguette.CompositeModelView.extend({\r\n\r\n       tpl:\"<p>{{name}}</p><p class='location'></p><p class='cars'></p>\",\r\n        nestedViews:{\r\n            '.cars':{\r\n                class:GarageView, // reusing our CollectionView we defined before\r\n                setElement:false, // will append INSIDE the container\r\n                collectionAttribute:'cars'\r\n            },\r\n            '.location':{\r\n                class:locationView,\r\n                modelAttribute:'location'\r\n            }\r\n        }\r\n    });\r\n\r\n    var myCompositeView = new compositeView({model:garageModel});\r\n    myCompositeView.render().$el.appendTo('body');\r\n/* RESULT :\r\n<div>\r\n <p>Peugeot</p>\r\n  <p class=\"location\">In Paris at gps coord 0.001</p>\r\n  <p class=\"cars\">\r\n    <ul>\r\n     <li>My car is a Toyota Yaris</li>\r\n     <li>My car is a BMW M3</li>\r\n    </ul>\r\n   </p>\r\n</div>\r\n*/\r\n```\r\n\r\nYou can specify that a nested view is deeply linked to one of our sub-models or sub-collections. You just have to define the collectionAttribute or the modelAttribute and assign it to the string value of the concerned model field. Magic!\r\n\r\n# Baguette Components\r\n\r\n```javascript\r\nvar MyViewClass = Backbone.Baguette.CompositeView.extend({\r\n   // properties goes here\r\n});\r\n\r\n// Classic instantiation of the view\r\nvar myView = new MyViewClass();\r\n\r\n```\r\n\r\n# Global Configuration","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Backbone-baguette","tagline":"Freshly toasted backbone library. Provides tools and helpers for a super quick backbone development in smalls to mediums applications."}