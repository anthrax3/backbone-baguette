{"tagline":"Freshly toasted backbone library. Provides tools and helpers for a super quick backbone development in smalls to mediums applications.","google":"","body":"# Backbone Baguette\r\n\r\nNothing better than concrete examples to understand how you can baguettize your Backbone development.\r\n\r\n###### Examples data\r\n\r\nAll the following examples will use the following models and collection : \r\n\r\n```javascript\r\n\r\n// Basic models and collection\r\nvar Car = Backbone.Model.extend({});\r\nvar toyota = new Car({brand:\"Toyota\",name:\"Yaris\"});\r\nvar bmw = new Car({brand:\"BMW\",name:\"M3\"});\r\n\r\nvar Garage = Backbone.Collection.extend({});\r\nvar myGarage = new Garage([toyota,bmw]);\r\n```\r\n###### Render a Model View\r\n\r\nWhen we're writing in Backbone, we quickly notice that we're writing a lot of similar views which are actually just using a template engine (such as Mustache or Handlebars) to render a JSON converted model. Instead of re-writing all the time the *template(this.model.toJSON())..* code you can baguettize it to achieve this.\r\n\r\n**With Backbone Baguette**\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.CompositeView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\",\r\n  tagName:\"div\"\r\n});\r\n\r\nvar myView = new ModelView({model:toyota});\r\n\r\nmyView.render().$el.appendTo('body'); // Appends to the body \"My car is a Toyota Yaris\"\r\n```\r\n\r\nHere we are using a \"classic\" Mustache-style template; but the default template engine used in Baguette is Handlebars. \r\n\r\nIf you wish to change this, you have to edit the global configuration of Baguette and change the templating function, which takes a string template and a JSON object and return the templated string. \r\n\r\n```javascript\r\nvar TemplatingFunction = function(tpl,data) {\r\n        return Handlebars.compile(tpl)(data);\r\n};\r\nBackbone.Baguette.templating = TemplatingFunction;\r\n```\r\n\r\nYou can also specify individually the templating property on each CompositeView, if you want to only edit some views and not the global Baguette templating function.\r\n\r\n```javascript\r\nvar ModelView = Backbone.Baguette.CompositeView.extend({\r\n  tpl:\"My car is a {{brand}} {{name}}\",\r\n  templating:function(tpl,data) {\r\n     return MyCustomTemplateEngine(tpl).CustomRenderMethod(data);\r\n  }\r\n  tagName:\"div\"\r\n});\r\n```\r\n\r\nSince I am a fanatic of [RequireJS](http://requirejs.org/), tpl attribute is for now only supporting a raw string because I'm using the awesome [text plugin](https://github.com/requirejs/text) to load asynchronosouly my .tpl files. Support for a jQuery selector to fetch a script text/template will be added soon!\r\n\r\n**Without Backbone Baguette**\r\n\r\nBasically we are rewriting all the time the good old render method which pretty much looks always the same...\r\n\r\n```javascript\r\nvar ModelView = Backbone.View.extend({\r\n\r\n    tagName:\"div\",\r\n    render:function() {\r\n      var templated = Handlebars.compile(tpl)(this.model.toJSON());\r\n      this.$el.html(templated);\r\n      return this;         \r\n    }  \r\n\r\n});\r\n```\r\n\r\n###### Rendering a collection\r\n\r\nYou can use a Composite View to **render a collection** and avoid to write the redundant *this.collection.each(....)* code.\r\n\r\nTo achieve this you can define the **modelView** parameter which is either a Backbone.View (or a Baguette CompositeView obviously) definition (not an instance!) or either a parameter object which can contain the traditional Backbone Views parameters to create an el, such as **tagName**, **className**, etc...\r\n\r\n**Creating a Collection View using a View definition**\r\n\r\n```javascript\r\nvar CarView = Backbone.Baguette.CompositeView.extend({\r\n   tpl:\"I have a {{brand}} {{name}} in my garage\",\r\n   events:{\r\n     \"click\":\"onClick\"\r\n   },\r\n   onClick:function() {\r\n    console.log(this.model.toJSON());\r\n   }\r\n});\r\n\r\nvar GarageView = Backbone.Baguette.CompositeView.extend({\r\n  tagName:\"ul\",\r\n  modelView:CarView\r\n});\r\n\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render();\r\n```\r\n\r\n*Your CarViews are passed all the options you gave to your GarageView instance; except obviously the options related to the DOM such as tagName, className, etc...*\r\n\r\n**Creating a Collection View using a parameter object**\r\n\r\n```javascript\r\nvar GarageView = Backbone.Baguette.CompositeView.extend({\r\n  tagName:\"ul\",\r\n  modelView:{\r\n   tagName:\"li\",\r\n   tpl:\"I have a {{brand}} {{name}} in my garage\"\r\n  }  \r\n});\r\n\r\nvar myGarageView = new GarageView({collection:myGarage});\r\n// Render the view => all the subsequent model views are created!\r\nmyGarageView.render();\r\n```\r\n*If you use a parameter object, Baguette will create \"anonymous\" views inside the render function for you. Therefore you won't be able to define custom attributes -like events or so- on these views, are they will be originals Baguette CompositeView objects.*\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\nvar GarageView = Backbone.View.extend({\r\n\r\n    render:function() {\r\n      this.$el.empty();\r\n      this.collection.each(function(model) {\r\n         var newView = new CarView({model:model});\r\n         this.$el.append(newView.render().$el);\r\n      })\r\n      return this;\r\n    }\r\n\r\n})\r\n```\r\n###### Auto bind your view\r\n\r\nBaguette automatically binds your View to the given model (or the given collection). That is, you don't need to rewrite the this.model.on(...) redundant code. We will here reuse the previous CarView.\r\n\r\n**With Backbone Baguette**\r\n\r\n```javascript\r\n\r\nvar myView = new CarView({model:toyota});\r\nmyView.render().$el.appendTo('body'); // <div>My car is a Toyota Yaris</div>\r\n\r\ntoyota.set({name:\"Yaris 2012\"});\r\n// View is automatically refreshed and is set to <div>My car is a Toyota Yaris 2012</div>\r\n```\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\nvar CarView = Backbone.View.extend({\r\n\r\n   initialize:function() {\r\n    this.model.on('change',this.render,this);\r\n   },\r\n   render:function() {\r\n    var templated = Handlebars.compile(tpl)(this.model.toJSON());\r\n    this.$el.html(templated);\r\n    return this;\r\n   }\r\n\r\n});\r\n```\r\n\r\nCollections are also auto binded. When you render a whole collection, Baguette is automatically binding the subsequent Model Views to the \"remove\" event of the assigned model. That is you don't need to care about this even if you are writing your own ModelView and passing it to the modelView attribute.\r\n\r\n```javascript\r\nvar myGarageView = new GarageView({collection:myGarage});\r\nmyGarageView.render().$el.appendTo('body');\r\n\r\nmyGarage.fetch(); // Will auto-render the view if new models are fetched\r\nmyGarage.add({brand:\"Peugeot\",name:\"306\"}); // View is refreshed with new model\r\nmyGarage.remove(toyota); // View is refreshed without the new model\r\n```\r\n\r\n**Without Backbone Baguette**\r\n\r\n```javascript\r\n\r\nvar GarageView = Backbone.View.extend({\r\n\r\n    initialize:function() {\r\n      this.collection.on('add reset remove',this.render,this);\r\n    },\r\n\r\n    render:function() {\r\n      this.$el.empty();\r\n      this.collection.each(function(model) {\r\n         var newView = new CarView({model:model});\r\n         this.$el.append(newView.render().$el);\r\n      })\r\n      return this;\r\n    }\r\n\r\n})\r\n```\r\n\r\n**I don't want my Composite Views to auto-bind themselves!**\r\n\r\nWell then you can right now exit this page. But seriously, you can just add the **noBind** attribute to the CompositeView and set it to **true**; either by defining it in your Class definition, either by passing it as an option when you instantiate your CompositeView.\r\n\r\n```javascript\r\nvar NoBindView = Backbone.Baguette.CompositeView.extend({\r\n   noBind:true\r\n});\r\n\r\n// Or you can just do\r\nnew Backbone.Baguette.CompositeView({noBind:true})\r\n```\r\n\r\n###### Create generic loaders for all your models/collections\r\n\r\nThis is not really a Baguette component, but actually Baguette in its source code is patching the **Backbone.sync** method to add a custom \"syncing\" event when an AJAX call is made. So, for instance, each time you want to fetch a model or a collection, the concerned object will emit the \"syncing\" event that you will be able to observe, just like the sync/change/reset events. You can then make a generic loader that will work everywhere on any model in your application :\r\n\r\n```javascript\r\nvar Loader = Backbone.View.extend({\r\n  tagName:'img',\r\n  className:'hidden',\r\n  attributes:{\r\n   'src':'loader.gif'\r\n  },\r\n  initialize:function() {\r\n   this.model.on('syncing',this.$el.show,this.$el);\r\n   this.model.on('change',this.$el.hide,this.$el);\r\n  }\r\n});\r\n\r\nvar customLoader = new Loader({model:toyota});\r\ncustomLoader.render().$el.appendTo('body');\r\ntoyota.fetch(); // Loader is displayed, and will hide when call is over.\r\n```\r\n\r\nIf you are **already overriding** Backbone.sync you can style call the custom Baguette implementation by using the Backbone.Baguette.sync reference\r\n\r\n```javascript\r\nBackbone.sync = function(method,model,options) {\r\n\r\n  // Doing my custom stuff here \r\n   \r\n  Backbone.Baguette.sync(method,model,options);\r\n}\r\n```\r\n\r\n###### Rendering Nested Views\r\n\r\nBaguette offers you the ability to manage your nested views in an elegant and simple way. We often need to embed views in a view in order to separate tasks, or for other many reasons. Let's say we want to build a view for a Car and insert to this view a Button that will react to a click. We don't want to bind the click event on the Car view since we can imagine the button View can be reused elsewhre on the application. \r\n\r\nYou can Baguettize it this way :\r\n\r\n```javascript\r\n\r\nvar SelectButton = Backbone.Baguette.CompositeView.extend({\r\n\r\n  tpl:'Info',\r\n  className:'btn btn-primary', // twitter bootstrap styling\r\n  events:{\r\n    'click':'onClick'\r\n  },\r\n  onClick:function() {\r\n    console.log(this.model.toJSON());\r\n    // Print informations or do stuff on Click.\r\n  } \r\n\r\n});\r\n\r\nvar CarView = Backbone.Baguette.CompositeView.extend({\r\n   \r\n  tpl:'<p></p><button class=\"info\"></button>',\r\n  nestedViews:{\r\n    \".info\":SelectButton\r\n  }\r\n\r\n});\r\n\r\nvar myCarView = new CarView({model:toyota});\r\nmyCarView.render().$el.appendTo('body');\r\n// The inner button is rendered and ready to handle the click!\r\n\r\n```\r\nIn the above example, our SelectButton class is instantiated within the CarView render method, and by default Baguette is using the selector as the **el** for our nested View. But you can also still auto-create the **el** for your nestedView, and add several others options by passing a parameter object which follows this syntax :\r\n\r\n###### Deeper dive in Nested Views : mixing it up\r\n\r\n\r\n# Baguette Components\r\n\r\nA CompositeView is a view that is a kind of hybrid view able to render a collection or a model following a **template** with a very few number of arguments. It avoids the redundant templating and collection looping code and allows us to write less code.\r\n\r\nJust like Backbone Views, you can (and you must!) inherit from a CompositeView to be able to use all its power.\r\n\r\n```javascript\r\nvar MyViewClass = Backbone.Baguette.CompositeView.extend({\r\n   // properties goes here\r\n});\r\n\r\n// Classic instantiation of the view\r\nvar myView = new MyViewClass();\r\n\r\n```\r\n\r\n# Global Configuration","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Backbone-baguette"}